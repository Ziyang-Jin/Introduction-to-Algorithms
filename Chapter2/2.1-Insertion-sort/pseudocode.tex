INSERTION-SORT (A)
1 for j = 2 to A.lengh
2  key = A[j]
3   // Insert A[j] into the sorted sequence A[1 ... j-1].
4   i = j - 1
5   while i > 0 and A[i] > key
6     A[i+1] = A[i]
7     i = i - 1
8   A[i+1] = key

Proof Using Loop Invariant:
  Initialization: We start by showing that the loop invariant holds before the first loop iteration, when j = 2. The subarray A[1 ... j-1], therefore, consists of just the single element A[1], which is in fact the original element in A[1]. Morevoer, this subarray is sorted (trivially, of course), which shows that the loop invariant holds prior to the first iteration of the loop.
  
  Maintenance: Informally, the body of the for loop works by moving A[j-1], A[j-2], A[j-3], and so on by one position to the right untill it fins the proper position for A[j] (lines 4 - 7), at which point it inserts the value of A[j] (line 8). The subarray A[1 .. j] then consists of the elements originally in A[1 ... j], but in sorted order. Incremnting j for the next iteration of the for loop the n preserves the loop invariant.
    A more formal treatment of the second property would require us to state and show a loop invariant for the while loop of lines 5 - 7.
  
  Termination: Finally, we examine what happens when the loop terminates. The condition causing the for loop to terminate is that j > .length = n. Because each loop iteration increases j by 1, we must have j = n + 1 at taht time. Substituting n + 1 for j in the wording of loop invariant, we have that subarray A[1 ... n] consists of the elements originally in A[1 ... n], but in sorted order. Observing that the subarray A[1 ... n], is the entire array, we conclude that the entire array is sorted. Hence, the algorithm is correct.
  
